import time
import json
import csv
import os
import threading
import queue
import tkinter as tk
import ctypes
import msvcrt  # ç”¨äºæ¸…é™¤è¾“å…¥ç¼“å†²åŒº
import numpy as np
import cv2
import mss
import keyboard
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from thefuzz import process
from rapidocr_onnxruntime import RapidOCR

# ================= é…ç½®ä¸å¸¸é‡ =================

REGIONS = {
    "hex_1": {'top': 540, 'left': 650,  'width': 320, 'height': 60},
    "hex_2": {'top': 540, 'left': 1130, 'width': 320, 'height': 60},
    "hex_3": {'top': 540, 'left': 1600, 'width': 320, 'height': 60}
}

COLORS = {
    "normal": "#00FF00",  # ç»¿è‰²
    "best":   "#FFD700",  # é‡‘è‰²
    "status": "yellow",   # é»„è‰²
    "error":  "#FF3333",  # çº¢è‰²
    "bg":     "#000000"   # èƒŒæ™¯é»‘
}

# ================= 1. æ•°æ®ç®¡ç† (Model) =================

class DataManager:
    """è´Ÿè´£åŠ è½½å’Œç®¡ç†é™æ€æ•°æ®"""
    def __init__(self):
        self.hero_data = {}
        self.pinyin_map = {}
        self.tier_map = {}
        # åŠ¨æ€è·å– data æ–‡ä»¶å¤¹çš„ç»å¯¹è·¯å¾„
        self.base_dir = os.path.dirname(os.path.abspath(__file__))
        self.data_dir = os.path.join(self.base_dir, 'data')
        self._load_data()

    def _load_data(self):
        print("--- æ­£åœ¨åŠ è½½æ•°æ®èµ„æº ---")

        # 1. åŠ è½½å¼ºåŒ–ç¬¦æ–‡ç­‰çº§æ˜ å°„ (ä¿®æ­£è·¯å¾„)
        tier_file = os.path.join(self.data_dir, 'tiers.json')
        if os.path.exists(tier_file):
            try:
                with open(tier_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                tier_cn_map = {"silver": "ç™½é“¶", "gold": "é»„é‡‘", "prismatic": "æ£±å½©"}
                for en_tier, cn_tier in tier_cn_map.items():
                    if en_tier in data:
                        for name in data[en_tier]: 
                            self.tier_map[name] = cn_tier
            except Exception as e:
                print(f"âš ï¸ {tier_file} åŠ è½½å¼‚å¸¸: {e}")

        # 2. åŠ è½½è‹±é›„æ•°æ® (CSV) (ä¿®æ­£è·¯å¾„)
        csv_path = os.path.join(self.data_dir, 'hero_augments.csv')
        if not os.path.exists(csv_path):
            print(f"âŒ é”™è¯¯: æ‰¾ä¸åˆ°æ–‡ä»¶ {csv_path}")
            print(f"   è¯·ç¡®è®¤è¯¥æ–‡ä»¶ä½äº: {self.data_dir}")
        else:
            try:
                encoding = 'utf-8-sig'
                try:
                    with open(csv_path, 'r', encoding=encoding) as f: f.read(100)
                except UnicodeDecodeError:
                    encoding = 'gbk'
                
                raw_hero_list = defaultdict(list)
                with open(csv_path, 'r', encoding=encoding) as f:
                    reader = csv.reader(f)
                    next(reader, None) # è·³è¿‡è¡¨å¤´
                    for row in reader:
                        if len(row) < 4: continue
                        hero = row[0].strip()
                        try: rank = int(row[2])
                        except: rank = 999
                        aug = row[3].strip()
                        raw_hero_list[hero].append((rank, aug))
                
                # æ„å»ºæŸ¥è¯¢å­—å…¸
                for hero, aug_list in raw_hero_list.items():
                    aug_list.sort(key=lambda x: x[0])
                    counters = {"ç™½é“¶": 1, "é»„é‡‘": 1, "æ£±å½©": 1, "æœªçŸ¥": 1}
                    h_dict = {}
                    for g_rank, name in aug_list:
                        tier = self.tier_map.get(name, "æœªçŸ¥")
                        h_dict[name] = {
                            "g_rank": g_rank, 
                            "tier": tier, 
                            "t_rank": counters.get(tier, 1)
                        }
                        if tier in counters: counters[tier] += 1
                    self.hero_data[hero] = h_dict
                
                print(f"âœ… è‹±é›„æ•°æ®åŠ è½½å®Œæ¯•: å…± {len(self.hero_data)} ä¸ªè‹±é›„")
            except Exception as e:
                print(f"âŒ CSV è¯»å–ä¸¥é‡å¤±è´¥: {e}")

        # 3. åŠ è½½æ‹¼éŸ³æ˜ å°„ (ä¿®æ­£è·¯å¾„)
        pinyin_file = os.path.join(self.data_dir, 'pinyin_map.json')
        if os.path.exists(pinyin_file):
            try:
                with open(pinyin_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    for cn, py in data.items():
                        self.pinyin_map[py] = cn
                        self.pinyin_map[cn] = cn
            except Exception as e:
                print(f"âš ï¸ {pinyin_file} åŠ è½½å¼‚å¸¸: {e}")
        
        print("-> æ•°æ®åˆå§‹åŒ–å®Œæˆ")

    def search_hero(self, query):
        """è‹±é›„æœç´¢é€»è¾‘ (å¢å¼ºæ¨¡ç³ŠåŒ¹é…)"""
        query = query.strip().lower()
        
        # 1. å°è¯•æ‹¼éŸ³/ä¸­æ–‡ç›´æ¥åŒ¹é…
        matched_name = self.pinyin_map.get(query)
        
        # 2. å¦‚æœæ²¡æ‰¾åˆ°ï¼Œåœ¨æ•°æ®Keyä¸­æ¨¡ç³Šæœç´¢
        if not matched_name and self.hero_data:
            guess, score = process.extractOne(query, list(self.hero_data.keys()))
            if score > 60:
                matched_name = guess
                return matched_name, False # éç²¾ç¡®åŒ¹é…ï¼Œéœ€è¦ç¡®è®¤

        # 3. åç§°ä¿®æ­£ï¼šå¦‚æœæ‰¾åˆ°äº†åå­—ä½†æ•°æ®é‡Œæ²¡Key (å¦‚ ç§°å· vs æœ¬å)
        if matched_name and matched_name not in self.hero_data:
            real_name, score = process.extractOne(matched_name, list(self.hero_data.keys()))
            if score > 80:
                print(f"â„¹ï¸ è‡ªåŠ¨ä¿®æ­£æ˜ å°„: {matched_name} -> {real_name}")
                matched_name = real_name
            else:
                print(f"âŒ è­¦å‘Š: æ‰¾åˆ°äº† '{matched_name}' ä½†æ•°æ®åº“æ— æ­¤è‹±é›„æ•°æ®")
                return None, False

        if matched_name:
            return matched_name, True
            
        return None, False

# ================= 2. å›¾åƒåˆ†æ (Core Logic) =================

class GameAnalyzer:
    """è´Ÿè´£ OCR å’Œ å›¾åƒå¤„ç† (è§£å†³çº¿ç¨‹å®‰å…¨é—®é¢˜)"""
    def __init__(self, data_manager):
        self.dm = data_manager
        # OCR å¼•æ“æ˜¯çº¿ç¨‹å®‰å…¨çš„
        self.ocr = RapidOCR(use_angle_cls=False)
        # çº¿ç¨‹å±€éƒ¨å­˜å‚¨ï¼šè§£å†³ mss åœ¨å¤šçº¿ç¨‹ä¸‹çš„å´©æºƒé—®é¢˜
        self._thread_local = threading.local()
        # çº¿ç¨‹æ± 
        self.executor = ThreadPoolExecutor(max_workers=3)

    @property
    def sct(self):
        """è·å–å½“å‰çº¿ç¨‹ä¸“ç”¨çš„ mss å®ä¾‹"""
        if not hasattr(self._thread_local, "instance"):
            self._thread_local.instance = mss.mss()
        return self._thread_local.instance

    def capture_region(self, region):
        try:
            # å¿…é¡»è½¬æ¢ä¸º intï¼Œé˜²æ­¢æµ®ç‚¹æ•°å¯¼è‡´ mss æŠ¥é”™
            monitor = {
                "top": int(region["top"]),
                "left": int(region["left"]),
                "width": int(region["width"]),
                "height": int(region["height"]),
                "mon": 0
            }
            img = np.array(self.sct.grab(monitor))
            gray = cv2.cvtColor(img, cv2.COLOR_BGRA2GRAY)
            h, w = gray.shape
            # 2å€ä¸Šé‡‡æ ·æé«˜æ–‡å­—æ¸…æ™°åº¦
            return cv2.resize(gray, (w * 2, h * 2), interpolation=cv2.INTER_CUBIC)
        except Exception as e:
            print(f"æˆªå›¾å¤±è´¥: {e}")
            return None

    def _process_single(self, key, hero_cn):
        try:
            region = REGIONS[key]
            img = self.capture_region(region)
            
            if img is None:
                return {"key": key, "text": "æˆªå›¾é”™è¯¯", "error": True}

            res_ocr, _ = self.ocr(img)
            txt = "".join([line[1] for line in res_ocr]) if res_ocr else ""
            txt = txt.replace(" ", "").replace(".", "")

            res = {
                "key": key, "valid": False, "rank": 999, 
                "text": "", "highlight": False, "error": False
            }

            if not txt:
                res["text"] = "âŒ æ— æ–‡å­—"
                res["error"] = True
                return res

            hero_augments = self.dm.hero_data.get(hero_cn, {})
            if not hero_augments:
                res["text"] = "æ— æ•°æ®"
                res["error"] = True
                return res

            match_name = None
            
            # 1. ç²¾ç¡®åŒ¹é… (O(1))
            if txt in hero_augments:
                match_name = txt
            else:
                # 2. æ¨¡ç³ŠåŒ¹é…
                match, score = process.extractOne(txt, list(hero_augments.keys()))
                if score > 50:
                    match_name = match

            if match_name:
                info = hero_augments[match_name]
                # æ ¼å¼åŒ–æ˜¾ç¤ºå†…å®¹
                res["text"] = f"ã€{match_name}ã€‘\n{info.get('tier','?')}(No.{info.get('t_rank','?')})\næ€»No.{info.get('g_rank','?')}"
                res["valid"] = True
                res["rank"] = info.get('g_rank', 999)
            else:
                res["text"] = "âŒ æœªè¯†åˆ«"
                res["error"] = True
            
            return res
            
        except Exception as e:
            print(f"å¤„ç†å¼‚å¸¸ ({key}): {e}")
            return {"key": key, "text": "Error", "error": True}

    def analyze(self, hero_cn):
        if not hero_cn: return {}
        print(f"æ­£åœ¨åˆ†æ: {hero_cn}...")
        
        futures = []
        for key in ["hex_1", "hex_2", "hex_3"]:
            futures.append(self.executor.submit(self._process_single, key, hero_cn))
        
        results = {}
        valid_matches = []
        
        for f in futures:
            try:
                data = f.result()
                results[data["key"]] = data
                if data.get("valid"): valid_matches.append(data)
            except Exception as e:
                print(f"å¹¶å‘ä»»åŠ¡å¼‚å¸¸: {e}")

        # è®¡ç®—æœ€ä¼˜æ¨è
        if valid_matches:
            min_rank = min(item['rank'] for item in valid_matches)
            for item in valid_matches:
                if item['rank'] == min_rank:
                    results[item['key']]["highlight"] = True
        
        return results

# ================= 3. UI ç•Œé¢ (View) =================

class OverlayApp:
    def __init__(self, root, queue):
        self.root = root
        self.queue = queue
        self.labels = {}
        self.hide_timer = None
        
        self._setup_window()
        self._setup_labels()
        
        # å¯åŠ¨é˜Ÿåˆ—æ¶ˆæ¯ç›‘å¬
        self.root.after(100, self.process_queue)

    def _setup_window(self):
        self.root.title("ARAM Overlay")
        self.root.overrideredirect(True) # æ— è¾¹æ¡†
        self.root.attributes("-topmost", True) # ç½®é¡¶
        self.root.config(bg=COLORS["bg"])
        self.root.attributes("-transparentcolor", COLORS["bg"]) # èƒŒæ™¯é€æ˜
        
        # é¼ æ ‡ç©¿é€è®¾ç½® (Windows API)
        try:
            hwnd = ctypes.windll.user32.GetParent(self.root.winfo_id())
            old_style = ctypes.windll.user32.GetWindowLongW(hwnd, -20)
            # WS_EX_LAYERED | WS_EX_TRANSPARENT
            ctypes.windll.user32.SetWindowLongW(hwnd, -20, old_style | 0x80000 | 0x20)
        except Exception as e:
            print(f"ç©¿é€è®¾ç½®è­¦å‘Š: {e}")

        # è·å–ä¸»å±å¹•åæ ‡ï¼Œç”¨äºç›¸å¯¹å®šä½
        with mss.mss() as sct:
            m = sct.monitors[0]
            self.offset_x, self.offset_y = m['left'], m['top']
            self.root.geometry(f"{m['width']}x{m['height']}+{m['left']}+{m['top']}")

    def _setup_labels(self):
        font_style = ("Microsoft YaHei", 14, "bold")
        for key in REGIONS:
            lbl = tk.Label(self.root, text="", font=font_style, bg=COLORS["bg"], justify="left")
            self.labels[key] = lbl

    def process_queue(self):
        """ä¸»çº¿ç¨‹è½®è¯¢ï¼šå¤„ç†æ¥è‡ªåå°çº¿ç¨‹çš„æŒ‡ä»¤"""
        try:
            while True:
                msg = self.queue.get_nowait()
                cmd = msg.get("cmd")
                data = msg.get("data")
                
                if cmd == "UPDATE":
                    self.update_display(data)
                elif cmd == "STATUS":
                    self.show_status(data)
                elif cmd == "CLEAR":
                    self.clear_display()
        except queue.Empty:
            pass
        finally:
            self.root.after(50, self.process_queue)

    def clear_display(self):
        if self.hide_timer:
            self.root.after_cancel(self.hide_timer)
            self.hide_timer = None
        for lbl in self.labels.values():
            lbl.place_forget()

    def show_status(self, text):
        self.clear_display()
        lbl = self.labels['hex_2']
        lbl.config(text=text, fg=COLORS["status"])
        lbl.place(relx=0.5, rely=0.5, anchor="center")
        # çŠ¶æ€æç¤º2ç§’åæ¶ˆå¤±
        self.hide_timer = self.root.after(2000, self.clear_display)

    def update_display(self, results):
        self.clear_display()
        
        # å¼ºåˆ¶å¯¹é½ Y è½´
        base_y_abs = REGIONS['hex_1']['top']
        fixed_rel_y = base_y_abs - self.offset_y - 120

        for key, info in results.items():
            if not info.get("text"): continue
            
            lbl = self.labels[key]
            # é¢œè‰²é€»è¾‘
            if info["error"]:
                fg = COLORS["error"]
            elif info["highlight"]:
                fg = COLORS["best"]
            else:
                fg = COLORS["normal"]
            
            lbl.config(text=info["text"], fg=fg)
            
            r_left = REGIONS[key]['left'] - self.offset_x
            lbl.place(x=r_left, y=fixed_rel_y, anchor="nw")
            lbl.lift()

        # ç»“æœæ˜¾ç¤º5ç§’åæ¶ˆå¤±
        self.hide_timer = self.root.after(5000, self.clear_display)

# ================= 4. æ§åˆ¶é€»è¾‘ (Controller) =================

class InputController(threading.Thread):
    def __init__(self, app_queue, data_manager, analyzer):
        super().__init__(daemon=True)
        self.queue = app_queue
        self.dm = data_manager
        self.analyzer = analyzer
        self.current_hero = None

    def run(self):
        while True:
            self.select_hero_phase()
            self.listening_phase()

    def flush_input(self):
        """æ ¸å¿ƒä¿®å¤ï¼šå¼ºåˆ¶æ¸…ç©ºæ ‡å‡†è¾“å…¥ç¼“å†²åŒº"""
        while msvcrt.kbhit():
            msvcrt.getch()

    def select_hero_phase(self):
        self.queue.put({"cmd": "CLEAR"})
        self.show_console_window()
        
        time.sleep(0.1)
        os.system('cls')
        self.flush_input() # æ¸…ç©ºæ®‹ç•™æŒ‰é”®

        print("=== ARAM åŠ©æ‰‹ (F8é‡æ–°è¾“å…¥) ===")
        print(">>> è¯·è¾“å…¥è‹±é›„åç§° (æ‹¼éŸ³/ä¸­æ–‡):")

        while True:
            try:
                self.flush_input() # å†æ¬¡æ¸…ç©ºï¼Œç¡®ä¿è¾“å…¥å¹²å‡€
                raw = input("Input: ").strip()
            except EOFError: continue
            
            if not raw: continue
            
            name, exact = self.dm.search_hero(raw)
            if name:
                if not exact:
                    print(f"   çŒœä½ æ˜¯: {name}? (Enterç¡®è®¤ / né‡è¾“)")
                    self.flush_input()
                    if input().strip().lower() == 'n':
                        continue
                
                self.current_hero = name
                print(f"âœ… é”å®š: {name}")
                print(">>> åˆ‡å›æ¸¸æˆï¼ŒæŒ‰ [F6] åˆ†æ")
                
                self.queue.put({"cmd": "STATUS", "data": f"å½“å‰: {name}\næŒ‰ F6 åˆ†æ"})
                self.hide_console_window()
                break
            else:
                print("âŒ æœªæ‰¾åˆ°ï¼Œè¯·é‡è¯•")

    def listening_phase(self):
        self.flush_input() # æ¸…é™¤ç¡®è®¤æ—¶çš„å›è½¦é”®æ®‹ç•™
        
        is_selecting = False
        print("(ç›‘å¬ä¸­... æŒ‰ F8 é‡ç½®)")
        
        while not is_selecting:
            if keyboard.is_pressed('f6'):
                self.queue.put({"cmd": "STATUS", "data": "ğŸ” æ­£åœ¨åˆ†æ..."})
                
                # åœ¨åå°çº¿ç¨‹æ‰§è¡Œåˆ†æï¼Œä¸é˜»å¡UI
                results = self.analyzer.analyze(self.current_hero)
                
                self.queue.put({"cmd": "UPDATE", "data": results})
                time.sleep(1) # é˜²æŠ–

            if keyboard.is_pressed('f8'):
                is_selecting = True
                time.sleep(0.5) # é˜²æ­¢ F8 è¿å‡»
            
            time.sleep(0.05)

    @staticmethod
    def show_console_window():
        try:
            hwnd = ctypes.windll.kernel32.GetConsoleWindow()
            ctypes.windll.user32.ShowWindow(hwnd, 5) # SW_SHOW
            ctypes.windll.user32.SetForegroundWindow(hwnd)
        except: pass

    @staticmethod
    def hide_console_window():
        try:
            hwnd = ctypes.windll.kernel32.GetConsoleWindow()
            ctypes.windll.user32.ShowWindow(hwnd, 6) # SW_MINIMIZE (ä¿æŒæœ€å°åŒ–æ¯”å®Œå…¨éšè—æ›´å®‰å…¨)
        except: pass

# ================= 5. ä¸»å…¥å£ =================

def main():
    # ã€å…³é”®ä¿®å¤ã€‘å¼ºåˆ¶è®¾ç½®å·¥ä½œç›®å½•ä¸ºè„šæœ¬æ‰€åœ¨ç›®å½•
    # è§£å†³å¿«æ·æ–¹å¼æˆ–ä¸åŒç»ˆç«¯å¯åŠ¨å¯¼è‡´æ‰¾ä¸åˆ°æ–‡ä»¶çš„é—®é¢˜
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)
    print(f"Working Directory: {script_dir}")

    # 1. åˆå§‹åŒ–æ ¸å¿ƒæ•°æ®ä¸é€»è¾‘
    dm = DataManager()
    
    if not dm.hero_data:
        print("âŒ è­¦å‘Š: æœªåŠ è½½åˆ°ä»»ä½•è‹±é›„æ•°æ®ï¼Œè¯·æ£€æŸ¥CSVæ–‡ä»¶ã€‚")
        input("æŒ‰ä»»æ„é”®é€€å‡º...")
        return

    analyzer = GameAnalyzer(dm)
    
    # 2. åˆå§‹åŒ– UI ä¸ é€šä¿¡é˜Ÿåˆ—
    root = tk.Tk()
    msg_queue = queue.Queue()
    app = OverlayApp(root, msg_queue)
    
    # 3. å¯åŠ¨åå°æ§åˆ¶çº¿ç¨‹
    controller = InputController(msg_queue, dm, analyzer)
    controller.start()
    
    # 4. è¿›å…¥ UI ä¸»å¾ªç¯
    print("ç¨‹åºå·²å¯åŠ¨...")
    try:
        root.mainloop()
    except KeyboardInterrupt:
        os._exit(0)

if __name__ == "__main__":
    main()